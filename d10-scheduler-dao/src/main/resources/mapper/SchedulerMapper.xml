<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.github.krystalics.d10.scheduler.dao.mapper.SchedulerMapper">

    <select id="readCouldTimeTriggered" resultType="com.github.krystalics.d10.scheduler.dao.biz.VersionInstance">
        select instance_id as instanceId,
               i.state     as state
        from task as t
                 join version as v
                      on t.task_id = v.task_id
                 join instance i
                      on v.last_instance_id = i.instance_id

        where t.schedule_type = 0
          and i.task_id between #{left} and #{right}
<![CDATA[ and i.state = 1
          and t.state = 2
          and start_time_theory <= NOW()
        ]]>
    </select>

    <select id="readCouldScheduledTasks" resultType="com.github.krystalics.d10.scheduler.dao.biz.VersionInstance">
        select i.task_id          as taskId,
               i.version_id       as versionId,
               instance_id        as instanceId,
               version_no         as versionNo,
               retry_remain_times as retryRemainTimes,
               start_time_theory  as startTimeTheory,
               i.job_conf         as jobConf,
               i.state            as state,
               job_log_address    as jobLogAddress,
               run_start_time     as runStartTime,
               run_end_time       as runEndTime,
               node               as node,
               auto_start         as autoStart,
               i.ctime            as ctime,
               i.mtime            as mtime

        from task as t
                 join version as v
                      on t.task_id = v.task_id
                 join instance i
                      on v.last_instance_id = i.instance_id

        where i.task_id between #{left} and #{right}
<![CDATA[ and i.state = #{state}
          and t.state = 2
        ]]>
    </select>

    <select id="readNeedPreparedTasks" resultType="com.github.krystalics.d10.scheduler.dao.biz.VersionInstance">
        select
        instance_id as instanceId,
        i.state as state,
        t.queue_name as queueName,
        t.cpu_avg as cpuAvg,
        t.memory_avg as memoryAvg
        from task as t
        join version as v
        on t.task_id = v.task_id
        join instance i
        on v.last_instance_id = i.instance_id

        where i.task_id between #{left} and #{right}
        <if test="state = 1">
            and t.schedule_type = 1
        </if>
        <![CDATA[ and i.state = #{state} and t.state = 2]]>
    </select>

    <update id="batchUpdateState" parameterType="java.util.List">
        UPDATE instance
        SET state = CASE
        <foreach collection="list" item="item" index="index">
            WHEN instance_id = #{item.instanceId} THEN #{item.state}
        </foreach>
        END
        WHERE instance_id IN
        <foreach collection="list" index="index" item="item" open="(" separator="," close=")">
            #{item.instanceId}
        </foreach>
    </update>

    <select id="checkUpInstancesAreSuccess">
        select count(1)
        from instance_rely ir
                 join version v
                      on ir.up_task_id = v.task_id and ir.up_version_no = v.version_no
                 join instance i
                      on v.last_instance_id = i.instance_id
        where ir.instance_id = #{instanceId}
          and i.state != 5;
    </select>

    <select id="routingSchedulingInstances" resultType="com.github.krystalics.d10.scheduler.dao.biz.VersionInstance">
        select instance_id       as instanceId,
               i.state           as state,
               t.queue_name      as queueName,
               t.cpu_avg         as cpuAvg,
               t.memory_avg      as memoryAvg,
               start_time_theory as startTimeTheory

        from task as t
                 join version as v
                      on t.task_id = v.task_id
                 join instance i
                      on v.last_instance_id = i.instance_id

        where i.task_id between #{left} and #{right}
        <![CDATA[
          and i.state < 5
          and t.state = 2
          and start_time_theory <= NOW()
        ]]>
    </select>

    <update id="updateState">
        UPDATE instance
        SET state = #{state}
        WHERE instance_id = #{instanceId}
    </update>


</mapper>
